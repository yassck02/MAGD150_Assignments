<html>
  </header>
   <script type="text/javascript" src="https://raw.githubusercontent.com/processing-js/processing-js/v1.4.8/processing.js"></script>
  </header>
  
  
  
  
  
  
   <!*********************************************************************************>
  <br />
  <br />  
  <br />
  <!*********************************************************************************>
  

  
  
  <h1>My Final sketch</h1>
  <script type="text/processing" data-processing-target="mycanvas0">
    
Tank player1 = new Tank(1); //player 1
Tank player2 = new Tank(2); //player 2

PImage blueTank;
PImage redTank;
PImage startScreen;

boolean shouldShowStartScreen = true;
boolean gameOver = false;

PowerUp powerUps[] = new PowerUp[3]; //array of powerups
Wall walls[] = new Wall[7]; //array of walls

void setup() {
  size(1000, 700);
  colorMode(HSB);
  rectMode(CENTER);
  imageMode(CENTER);
  textMode(CENTER);
  textAlign(CENTER);
  textSize(50);
  noSmooth();
  noStroke();

  //frameRate(15);

 blueTank = loadImage("https://cloud.githubusercontent.com/assets/14878231/11768026/c02c325a-a185-11e5-95b5-5119d7f58eb6.png");
  redTank = loadImage("https://cloud.githubusercontent.com/assets/14878231/11768027/c4b99998-a185-11e5-99d5-47877506a515.png");
  startScreen = loadImage("https://cloud.githubusercontent.com/assets/14878231/11768024/b6df1c94-a185-11e5-9693-eeb23ee27f26.png");


  for (int i = 0; i < powerUps.length; i++) { //Initanizes each item in the array as a new powerup
    powerUps[i] = new PowerUp();
  }

  walls[0] = new Wall(50, height/2, height); //left wall
  walls[1] = new Wall(width-50, height/2, height); //right wall
  walls[2] = new Wall(width/2, height/2, 300); //center wall
  walls[3] = new Wall(width/4, height/4, 200); //left top wall
  walls[4] = new Wall(width/4, 3*height/4, 200); //left bottom wall
  walls[5] = new Wall(3*width/4, height/4, 200); //right top wall
  walls[6] = new Wall(3*width/4, 3*height/4, 200); //right bottom wall
}

void draw() {

  if (shouldShowStartScreen) {
    image(startScreen, width/2, height/2);
  } else {

    background(#AAD137); //grass

    for (int i = 0; i < powerUps.length; i++) {
      powerUps[i].display();
      powerUps[i].collect(player1);
      powerUps[i].collect(player2);
    }

    for (int i = 0; i < walls.length; i++) {
      walls[i].display();
    }

    player1.display();
    player1.move();
    player1.displayScore(200, 50);

    player2.display();
    player2.move();
    player2.displayScore(800, 50);

    if (player1.bullet.isFired) {
      player1.bullet.move();
    }
    if (player2.bullet.isFired) {
      player2.bullet.move();
    }

     println(" - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ");
     println("[PLAYER 1] - " + player1.keys[0] + ", " + player1.keys[1] + ", " +player1.keys[2] + ", " + player1.keys[3]);
     println("(" + player1.pos.x + ", " + player1.pos.y + ")");
     println("angle = " + player1.angle);
     println("health = " + player1.health);
     println("able to fire: " + player1.ableToFire);
     println(" - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ");
     println("[PLAYER 2] - " + player2.keys[0] + ", " + player2.keys[1] + ", " +player2.keys[2] + ", " + player2.keys[3]);
     println("(" + player2.pos.x + ", " + player2.pos.y + ")");
     println("angle = " + player2.angle);
     println("health = " + player2.health);
     println("able to fire: " + player2.ableToFire);
     
  }
}

void gameOver(Tank t) {
  filter(BLUR, 4);
  textSize(100);
  fill(0, 0, 0);
  text("GAME OVER", width/2, 200);
  fill(t.hue, 255, 160, 255);
  textSize(75);
  text("Player " + t.number + " wins!", width/2, 275);
  textSize(30);
  fill(0, 0, 0);
  text("click to reset...", width/2, 450);
  gameOver = true;
  player1.ableToFire = false;
  player2.ableToFire = false;
  noLoop();
}

void resetGame() {
  gameOver = false;
  player1.health = player2.health = 100;
  player1.pos.x = 200;
  player1.pos.y = 200;
  player2.pos.x = 800;
  player2.pos.y = 200;
  player1.ableToFire = true;
  player2.ableToFire = true;
}

void keyPressed() {
  player1.keyPressed();
  player2.keyPressed();
}
void keyReleased() {
  player1.keyReleased();
  player2.keyReleased();
}

void mousePressed() {
  if (gameOver) {
    loop();
    resetGame();
  }
  if (shouldShowStartScreen) {
    shouldShowStartScreen = false;
  }
}







class Bullet {
  PVector pos  = new PVector(0.0, 0.0);

  int radius = 10;
  float speed = 0.05;

  boolean canBounce = true;

  boolean isFired = false;
  float angle;
  float normalAngle;

  Tank targetTank;
  Tank parentTank;


  Bullet() {
  }

  void Launch(Tank parent, float a, Tank target) {
    targetTank = target;
    parentTank = parent;
    pos.x = parentTank.pos.x;
    pos.y = parentTank.pos.y;

    angle = a;
    parentTank.ableToFire = false;
    isFired = true;
  }

  void move() {
    pos.x += 1/(speed/cos(angle));
    pos.y += 1/(speed/sin(angle));

    if (isFired) {
      display();
    }

    if (dist(pos.x, pos.y, targetTank.pos.x, targetTank.pos.y) <= 35) { //if the missile gets close enough to the target tank...
      parentTank.ableToFire = true; //allow the tank that shot this missile to fire again
      targetTank.health -= 10; //subrtact 10 health from target tank
      resetBullet();
      if (targetTank.health <= 0) { //cap the health at min 0
        targetTank.health = 0;
        gameOver(parentTank); //parent tank wins if the target tank (the other tank) looses
      }
    }

    for (int i = 0; i < walls.length; i++) {
      if (((pos.x >= walls[i].pos.x - walls[i].W/2)&&(pos.x <= walls[i].pos.x + walls[i].W/2))&&((pos.y >= walls[i].pos.y - walls[i].H/2)&&(pos.y <= walls[i].pos.y + walls[i].H/2))) { 
        if (canBounce) {

          normalAngle = PI;

          angle = (2*normalAngle - PI - angle); //calculate bounce angle
          canBounce = false;
        } else { //if the bullet hits a wall and is unable to bounce...
          resetBullet();
        }
      }
    }


    if ((pos.x < 0)||(pos.x > width)||(pos.y < 0)||(pos.y > height)) { //if the bullet goes off the screen...      
      resetBullet();
    }
  }

  void resetBullet() {
    pos.x = parentTank.pos.x; //set the bullet position to the parent tanks position
    pos.y = parentTank.pos.y;
    parentTank.ableToFire = true; //allow the tank that shot this missile to fire again
    isFired = false;
    normalAngle = 0;
    canBounce = true;
  }
  
  
  
  
  
  class Tank {
  PVector pos  = new PVector(0.0, 0.0);

  float forwardSpeed = .5;
  float backwardSpeed = .5;

  float rotateSpeed = .025;
  float angle;

  int health = 100;
  boolean ableToFire = true;
  Bullet bullet = new Bullet();

  int hue; //not related to the tank color...
  int number;
  boolean keys[] = {false, false, false, false, false, false}; // W A S D Q *or* I J K L O
  boolean controlScheme; //if true then player uses WASD if false then player uses IJKL

  Tank(int num) {
    number = num;
    if (num == 1) {
      controlScheme = true;
      pos.x = 200;
      pos.y = 200;
      hue = 0;
      angle = 0;
    } else if (num == 2) {
      controlScheme = false;
      pos.x = 800;
      pos.y = 200;
      hue = 155;
      angle = 3.14;
    }
  }

  void display() {
    translate(pos.x, pos.y);
    rotate(angle);

    if (controlScheme) { //display red tank for player 1 and blue for 2
      image(redTank, 0, 0);
    } else {
      image(blueTank, 0, 0);
    }

    rotate(-angle);
    translate(-1*pos.x, -1*pos.y); //reset the origin to the top left of the screen
  }

  void move() {
    if (keys[0]) { //WWWWW
      pos.x += 1/(forwardSpeed/cos(angle));
      pos.y += 1/(forwardSpeed/sin(angle));
    }
    if (keys[1]) { //AAAAA
      angle -= rotateSpeed;
    }
    if (keys[2]) { //SSSSS
      pos.x -= 1/(backwardSpeed/cos(angle));
      pos.y -= 1/(backwardSpeed/sin(angle));
    }
    if (keys[3]) { //DDDDD
      angle += rotateSpeed;
    }
    if (keys[4]) {
      if (ableToFire) {
        if (number == 1) {
          bullet.Launch(player1, angle, player2); //first parrameter is the parent tank second is the target
        } else if (number == 2) {
          bullet.Launch(player2, angle, player1); //first parrameter is the parent tank second is the target
        }
      }
    }
  } 

  void displayScore(int x, int y) { //x,y are the position of the displayted score, h is the color
    textSize(30);
    fill(hue, 255, 160, 255);
    text("Player " + number +": " + health, x, y);
  }

  void keyPressed() {
    if (controlScheme == true) {
      if (key == 'w') {
        keys[0] = true;
      }
      if (key == 'a') {
        keys[1] = true;
      }
      if (key == 's') {
        keys[2] = true;
      }
      if (key == 'd') {
        keys[3] = true;
      }
      if (key == 'q') {
        keys[4] = true;
      }
    } else if (controlScheme == false) {
      if (key == 'i') {
        keys[0] = true;
      }
      if (key == 'j') {
        keys[1] = true;
      }
      if (key == 'k') {
        keys[2] = true;
      }
      if (key == 'l') {
        keys[3] = true;
      }
      if (key == 'o') {
        keys[4] = true;
      }
    }
  }

  void keyReleased() {
    if (controlScheme == true) {
      if (key == 'w') {
        keys[0] = false;
      } 
      if (key == 'a') {
        keys[1] = false;
      }
      if (key == 's') {
        keys[2] = false;
      }
      if (key == 'd') {
        keys[3] = false;
      }
      if (key == 'q') {
        keys[4] = false;
      }
    } 
    if (controlScheme == false) {
      if (key == 'i') {
        keys[0] = false;
      } 
      if (key == 'j') {
        keys[1] = false;
      }
      if (key == 'k') {
        keys[2] = false;
      }
      if (key == 'l') {
        keys[3] = false;
      }
      if (key == 'o') {
        keys[4] = false;
      }
    }
  }
}







class Wall {
  PVector pos = new PVector(0.0, 0.0);
  int H;
  int W;

  Wall(int x, int y, int h) {
    pos.x = x;
    pos.y = y;
    H = h;
    W = 20;
  }

  void display() {
    noStroke();
    fill(25, 85, 255);
    rect(pos.x, pos.y, W, H);
  }
}



class PowerUp {
  PVector pos  = new PVector(0.0, 0.0);
  float r;
  float r2;

  float startTime;

  float h; //hue (color)
  float t = 255; //transparency

  PowerUp() {
    r = 10;
    r2 = 50; //ending circle radius
    h = 0;
    randomPosition(); // give the circle a random position
  }

  void display() { 
    update();
    noStroke();
    fill(h, 0, 255, 255);
    ellipse(pos.x, pos.y, 20, 20); //constant dot
    noFill();
    strokeWeight(4);
    stroke(h, 0, 255, t); 
    ellipse(pos.x, pos.y, r, r); //growing ring
  }

  void update() {
    r = lerp(r, r2, 0.04); // increase current raduis (r) to max radius (r2) by step 0.04
    t = (255*(1-(r/r2))); //decrease transparency (as a percentage of the radius)

    if (r >= r2*.95) {
      r = 0;
      t = 255;
    }
  }

  void collect(Tank T) {
    if ((dist(T.pos.x, T.pos.y, pos.x, pos.y) <= 30)&&(T.health < 100)){ //if the tank is close enough to the health and the health of the tank is less than max 100...
      T.health += 5;
      randomPosition();
    }
  }

  void randomPosition() {
    pos.x = random(r, width-r); //random width position
    pos.y = random(r, height-r); //random height position
  }
}

  void display() {
    noStroke();
    fill(0, 0, 0);
    translate(pos.x, pos.y);
    ellipse(0, 0, radius, radius);
    translate(-1*pos.x, -1*pos.y);
  }
}

    
  </script>
  <canvas id="mycanvas0"></canvas>
  <p>Red player uses WASD to move and Q to shoot</p>
  <p>Blue player uses IJKL to move and O to shoot</p>
  <p>Bounce the bullets off the walls and collect the whit health boosts</p>
  


    
  <!*********************************************************************************>
  <br />
  <br />  
  <br />
  <!*********************************************************************************>
  

  
  
  <h1>My First sketch</h1>
  <script type="text/processing" data-processing-target="mycanvas1">
    
   void setup(){
  
   size(400,400);
   background(0, 0, 0);
   
   //dots(background) 
   for(int x = 1; x < 400; x++){  
     for(int y = 1; y < 400; y++){  
       if ((x % 10 == 0) && (y % 10 == 0)){
         stroke(random(255), random(255), random(255));
           point(x,y);
       }
     }
   }
   
   //coin shape
   stroke(0, 0, 0); //black
   fill(200, 200, 200); //light grey
   ellipseMode(CENTER);
   ellipse(200, 200, 360, 360);
   ellipse(200, 200, 345, 345);
   
   
   
   //dome
   ellipse(200, 160, 125, 100); 
   
   rectMode(CENTER);
   rect(200, 160, 175, 25);
   rect(200, 250, 300, 20);
   rect(200, 200, 275, 80);
   rect(200, 200, 250, 80);
   rect(200, 200, 200, 80);
   rect(200, 200, 100, 70);
   rect(200, 250, 125, 25);
   
   
   //stairs
   line(140, 257, 260, 257);
   line(150, 252, 250, 252);
   line(160, 247, 240, 247);
   line(170, 242, 230, 242);
   
   //angled roof
   triangle(150, 165, 200, 140, 250, 165);
   rect(200, 172, 100, 10); 
   
   //pillars (left to right, top rect to bottom)
   rectMode(CENTER);
   rect(160, 180, 15, 5);
   rect(160, 207, 7, 50);
   rect(160, 235, 15, 5); 
   
   rect(180, 180, 15, 5);
   rect(180, 207, 7, 50);
   rect(180, 235, 15, 5); 
   
   rect(220, 180, 15, 5);
   rect(220, 207, 7, 50);
   rect(220, 235, 15, 5); 
   
   rect(240, 180, 15, 5);
   rect(240, 207, 7, 50);
   rect(240, 235, 15, 5); 
   
   //door
   rect(200, 215, 20, 35);
   
   //windows (left to right)
   rectMode(CORNER);
   rect(83, 185, 10, 20);
   rect(120, 180, 15, 35);
   rect(265, 180, 15, 35);
   rect(308, 185, 10, 20);
   
   //text
   fill(50, 50, 50); //text color
   textSize(15);
   text("Five Cents", 165, 300); 
   textSize(25);
   text("United States of", 103, 330); 
   text("America", 155, 360); 
   textSize(20);
   text("E Pluribus Unum", 120, 80); 
}

void draw () { //helps get coordinates when drawing
  println (mouseX +"," + mouseY);
} 
    
  </script>
  <canvas id="mycanvas1"></canvas>
  <p>A simple drawing of a coin using loops and primative processing shapes</p>

  
  
  
  

  <!*********************************************************************************>
  <br />
  <br />  
  <br />
  <!*********************************************************************************>
  
  
  
  
  
  
  
  <h1>My Fifth sketch</h1>
  <script type="text/processing" data-processing-target="mycanvas5">
    
    float posX = width/2;
float posY = height/2;
float speed = 3;
int roadWidth = 200;
color carColor;
int d;

void setup() {
  size(1200, 700);
  posX = width/2;
  posY = height/2;
  carColor = color(random(255), random(255), random(255));
  textSize(20);
  rectMode(CENTER);
  noStroke();
}

void draw() {

  background(#147900); //grass

  fill(#E0E0E0);
  rect(width/2, height/2, roadWidth+50, height+2);//gravel
  fill(#B9B9B9);
  rect(width/2, height/2, roadWidth, height+2);//pavement

  if (d>=height) {
    d = 0;
  }
  drawLines(d);
  d+=speed;


  if ((posX < width/2-roadWidth/2-25)||(posX > width/2+roadWidth/2+25)) { //if car goes off road, decrease speed
    if (frameCount % 10 == 0) {
      speed--;
    }
    if (speed <= 3) { //set minimum speed to 3
      speed = 3;
    }
  } else if (frameCount % 50 == 0) { // increase the speed every 50th frame
    speed++;
    if (speed >= 10) { //set speed cap at 10
      speed = 10;
    }
  }

  if (keyPressed == true) { //WASD car control
    switch(key) {
      case('w'):
      case('W'):
      posY -= speed;
      break;
      case('d'):
      case('D'):
      posX += speed*0.5; //right speed is half normal speed
      break;
      case('s'):
      case('S'):
      posY += speed;
      break;
      case('a'):
      case('A'):
      posX -= speed*0.5;//left speed is half normal speed
      break;
    }
  }
  drawCar(posX, posY); //draws Car on Screen

  fill(#FFFFFF);

  text("- Use the W A S D keys to move the car", 20, 30);
  text("- Click to change the color of the car", 20, 55);
  text("tip: Stay on the road to go faster", 20, 100);
  text("SPEED = "+speed, 1000, 30);
}

void drawCar(float x, float y) {
  stroke(#000000);

  fill(#292828);
  rect(x, y-25, 40, 5);//front Axle
  rect(x, y+25, 40, 5);//front Axle

  fill(#767676);//wheels
  rect(x-17, y-25, 10, 15, 4, 4, 4, 4);//FR
  rect(x+17, y-25, 10, 15, 4, 4, 4, 4);//FL
  rect(x-17, y+25, 10, 15, 4, 4, 4, 4);//RL
  rect(x+17, y+25, 10, 15, 4, 4, 4, 4);//RR

  fill(carColor);
  rect(x, y-5, 10, 75);//middle thin rectangle

  beginShape(); //front Fin
  vertex(x-10, y-45);
  vertex(x-18, y-35);
  vertex(x+18, y-35);
  vertex(x+10, y-45);
  endShape(CLOSE);

  triangle(x, y-25, x+15, y-10, x-15, y-10);//front triangle
  rect(x, y-5, 30, 10);//niddle rectangle
  triangle(x, y+30, x+15, y, x-15, y);//back triangle

  rect(x, y+35, 25, 7);//back fin

  beginShape();
  vertex(x, y+15);
  vertex(x-5, y);
  vertex(x-5, y-5);
  vertex(x+5, y-5);
  vertex(x+5, y);
  endShape(CLOSE);
}

void drawLines(int s) {
  stroke(#FFF300);

  for (int q = -1*height; q <= height; q+=100) {
    line(width/2, s+q, width/2, s+q+50);
  }
}

void mousePressed() {
  carColor = color(random(255), random(255), random(255)); //Changes color of car
}
    
  </script>
  <canvas id="mycanvas5"></canvas>
  <p>A simple car simulator. Stay on the road to go faster.</p>
   <p>Use WASD to move</p>


  <!*********************************************************************************>
  <br />
  <br />  
  <br />
  <!*********************************************************************************>
  

  
  
  
  
  <h1>My Sixth sketch</h1>
  <script type="text/processing" data-processing-target="mycanvas6">
    
   color currentColor;
color selectedColor;
color backgroundColor = color(0, 0, 0);
float r = random(0, TWO_PI); // ring rotation
float spiralOrientation = 0;
float triangleOrientation = 0;
boolean bool = false;


void setup() {
  size(800, 800);
  background(backgroundColor);
  noCursor();
  rectMode(CENTER);
  colorMode(HSB);
}


void draw() {
  background(backgroundColor);

  drawDots();
  drawGradientCircle();
  drawSpiral(spiralOrientation);
  drawSpinningCircles();
  drawCursor();
  drawCircleOfLines();
  drawTriangle(width/2, height/2, triangleOrientation);
  
  if(bool){
    filter(INVERT);
  }

  spiralOrientation = spiralOrientation - 0.1;
  triangleOrientation = triangleOrientation + 0.025;
}

void drawGradientCircle() {
  noFill();
  for (float t = 0.0; t <= TWO_PI; t = t + .15) {
    currentColor = color(255*(t/TWO_PI), 255, 255);
    stroke(currentColor);
    strokeWeight(20);
    point(width/2+200*cos(t), height/2+200*sin(t));
    stroke(0, 0, 255);
    strokeWeight(15);
    point(width/2+200*cos(t), height/2+200*sin(t));
  }
}

void drawSpinningCircles() {
  noFill();
  stroke(0, 0, 255);
  strokeWeight(2);
  ellipse(width/2, height/2, 450, 450);
  ellipse(width/2, height/2, 350, 350);

  strokeWeight(8);
  arc(width/2, height/2, 450, 450, triangleOrientation-PI/8+PI/3, triangleOrientation+PI/8+PI/3);
  arc(width/2, height/2, 350, 350, triangleOrientation-PI/16+PI/3, triangleOrientation+PI/16+PI/3);

  arc(width/2, height/2, 450, 450, triangleOrientation-PI/8+PI, triangleOrientation+PI/8+PI);
  arc(width/2, height/2, 350, 350, triangleOrientation-PI/16+PI, triangleOrientation+PI/16+PI);

  arc(width/2, height/2, 450, 450, triangleOrientation-PI/8-PI/3, triangleOrientation+PI/8-PI/3);
  arc(width/2, height/2, 350, 350, triangleOrientation-PI/16-PI/3, triangleOrientation+PI/16-PI/3);
}


void drawCursor() {
  noFill();
  int x = mouseX;
  int y = mouseY;

  stroke(0, 0, 255);
  strokeWeight(1);
  noFill();

  stroke(0, 0, 255);
  line(x+10, y, x-10, y); //crosshairs
  line(x, y-10, x, y+10);


  if (mousePressed) {
    rect(x, y, 35, 35); //rect
  } else {
    line(x-20, y-20, x-10, y-20); //corners only
    line(x+20, y-20, x+10, y-20);
    line(x-20, y+20, x-10, y+20);
    line(x+20, y+20, x+10, y+20);

    line(x-20, y-20, x-20, y-10);
    line(x+20, y-20, x+20, y-10);
    line(x-20, y+20, x-20, y+10);
    line(x+20, y+20, x+20, y+10);
  }

  //r = atan2((1.0*mouseY-height/2), (1.0*mouseX-width/2)); //angle from center based on mouse position
}

void drawSpiral(float a) {
  stroke(0, 0, 255);
  fill(0, 0, 255);
  strokeWeight(1);
  ellipse(width/2, height/2, 7, 7);
  for (float z = 0; z <= PI*18.5; z = z + 0.005) {
    point(width/2+3*z*cos(z+a), height/2+3*z*sin(z+a));
  }
}

void drawCircleOfLines() {
  for (float t = 0.0; t <= TWO_PI; t = t + .1) {
    strokeWeight(2);
    line (width/2+250*cos(t), height/2+250*sin(t), width/2+255*cos(t), height/2+255*sin(t));
  }
}

void drawDots() {
  strokeWeight(1);
  stroke(0, 0, 255);
  for (int q = 0; q <= 10; q++) {
    point(random(width), random(height));
  }
}

void drawTriangle(int x, int y, float b) {
  stroke(0, 0, 255);
  beginShape();
  for (float s = b; s <= b + TWO_PI; s = s + 2*PI/3) {
    vertex(x+250*cos(s), y+250*sin(s));
  }
  endShape(CLOSE);
}

void mousePressed(){
  bool =! bool;
}
   
  </script>
  <canvas id="mycanvas6"></canvas>
  <p>A sci-fi design inspired by a HUD of a robot</p>
  

  
  
  <!*********************************************************************************>
  <br />
  <br />  
  <br />
   <!*********************************************************************************>

  
  
 <a href="https://raw.githubusercontent.com/yassck02/MAGD150_Assignments/gh-pages/index.html">8</a>
  
  </body>
</html> 

