<html>
  </header>
   <script type="text/javascript" src="https://raw.githubusercontent.com/processing-js/processing-js/v1.4.8/processing.js"></script>
  </header>
  
  
  
  
  
  
   <!*********************************************************************************>
  <br />
  <br />  
  <br />
  <!*********************************************************************************>
  

  
  
  <h1>My Final sketch</h1>
  <script type="text/processing" data-processing-target="mycanvas0">
    
Tank player1 = new Tank(1); //player 1
Tank player2 = new Tank(2); //player 2

PImage blueTank;
PImage redTank;
PImage startScreen;

boolean shouldShowStartScreen = true;
boolean gameOver = false;

PowerUp powerUps[] = new PowerUp[3]; //array of powerups
Wall walls[] = new Wall[7]; //array of walls

void setup() {
  size(1000, 700);
  colorMode(HSB);
  rectMode(CENTER);
  imageMode(CENTER);
  textMode(CENTER);
  textAlign(CENTER);
  textSize(50);
  noSmooth();
  noStroke();

  //frameRate(15);

  blueTank = loadImage("TankBlue.png");
  redTank = loadImage("TankRed.png");
  startScreen = loadImage("startScreen.png");

  for (int i = 0; i < powerUps.length; i++) { //Initanizes each item in the array as a new powerup
    powerUps[i] = new PowerUp();
  }

  walls[0] = new Wall(50, height/2, height); //left wall
  walls[1] = new Wall(width-50, height/2, height); //right wall
  walls[2] = new Wall(width/2, height/2, 300); //center wall
  walls[3] = new Wall(width/4, height/4, 200); //left top wall
  walls[4] = new Wall(width/4, 3*height/4, 200); //left bottom wall
  walls[5] = new Wall(3*width/4, height/4, 200); //right top wall
  walls[6] = new Wall(3*width/4, 3*height/4, 200); //right bottom wall
}

void draw() {

  if (shouldShowStartScreen) {
    image(startScreen, width/2, height/2);
  } else {

    background(#AAD137); //grass

    for (int i = 0; i < powerUps.length; i++) {
      powerUps[i].display();
      powerUps[i].collect(player1);
      powerUps[i].collect(player2);
    }

    for (int i = 0; i < walls.length; i++) {
      walls[i].display();
    }

    player1.display();
    player1.move();
    player1.displayScore(200, 50);

    player2.display();
    player2.move();
    player2.displayScore(800, 50);

    if (player1.bullet.isFired) {
      player1.bullet.move();
    }
    if (player2.bullet.isFired) {
      player2.bullet.move();
    }

     println(" - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ");
     println("[PLAYER 1] - " + player1.keys[0] + ", " + player1.keys[1] + ", " +player1.keys[2] + ", " + player1.keys[3]);
     println("(" + player1.pos.x + ", " + player1.pos.y + ")");
     println("angle = " + player1.angle);
     println("health = " + player1.health);
     println("able to fire: " + player1.ableToFire);
     println(" - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ");
     println("[PLAYER 2] - " + player2.keys[0] + ", " + player2.keys[1] + ", " +player2.keys[2] + ", " + player2.keys[3]);
     println("(" + player2.pos.x + ", " + player2.pos.y + ")");
     println("angle = " + player2.angle);
     println("health = " + player2.health);
     println("able to fire: " + player2.ableToFire);
     
  }
}

void gameOver(Tank t) {
  filter(BLUR, 4);
  textSize(100);
  fill(0, 0, 0);
  text("GAME OVER", width/2, 200);
  fill(t.hue, 255, 160, 255);
  textSize(75);
  text("Player " + t.number + " wins!", width/2, 275);
  textSize(30);
  fill(0, 0, 0);
  text("click to reset...", width/2, 450);
  gameOver = true;
  player1.ableToFire = false;
  player2.ableToFire = false;
  noLoop();
}

void resetGame() {
  gameOver = false;
  player1.health = player2.health = 100;
  player1.pos.x = 200;
  player1.pos.y = 200;
  player2.pos.x = 800;
  player2.pos.y = 200;
  player1.ableToFire = true;
  player2.ableToFire = true;
}

void keyPressed() {
  player1.keyPressed();
  player2.keyPressed();
}
void keyReleased() {
  player1.keyReleased();
  player2.keyReleased();
}

void mousePressed() {
  if (gameOver) {
    loop();
    resetGame();
  }
  if (shouldShowStartScreen) {
    shouldShowStartScreen = false;
  }
}







class Bullet {
  PVector pos  = new PVector(0.0, 0.0);

  int radius = 10;
  float speed = 0.05;

  boolean canBounce = true;

  boolean isFired = false;
  float angle;
  float normalAngle;

  Tank targetTank;
  Tank parentTank;


  Bullet() {
  }

  void Launch(Tank parent, float a, Tank target) {
    targetTank = target;
    parentTank = parent;
    pos.x = parentTank.pos.x;
    pos.y = parentTank.pos.y;

    angle = a;
    parentTank.ableToFire = false;
    isFired = true;
  }

  void move() {
    pos.x += 1/(speed/cos(angle));
    pos.y += 1/(speed/sin(angle));

    if (isFired) {
      display();
    }

    if (dist(pos.x, pos.y, targetTank.pos.x, targetTank.pos.y) <= 35) { //if the missile gets close enough to the target tank...
      parentTank.ableToFire = true; //allow the tank that shot this missile to fire again
      targetTank.health -= 10; //subrtact 10 health from target tank
      resetBullet();
      if (targetTank.health <= 0) { //cap the health at min 0
        targetTank.health = 0;
        gameOver(parentTank); //parent tank wins if the target tank (the other tank) looses
      }
    }

    for (int i = 0; i < walls.length; i++) {
      if (((pos.x >= walls[i].pos.x - walls[i].W/2)&&(pos.x <= walls[i].pos.x + walls[i].W/2))&&((pos.y >= walls[i].pos.y - walls[i].H/2)&&(pos.y <= walls[i].pos.y + walls[i].H/2))) { 
        if (canBounce) {

          normalAngle = PI;

          angle = (2*normalAngle - PI - angle); //calculate bounce angle
          canBounce = false;
        } else { //if the bullet hits a wall and is unable to bounce...
          resetBullet();
        }
      }
    }


    if ((pos.x < 0)||(pos.x > width)||(pos.y < 0)||(pos.y > height)) { //if the bullet goes off the screen...      
      resetBullet();
    }
  }

  void resetBullet() {
    pos.x = parentTank.pos.x; //set the bullet position to the parent tanks position
    pos.y = parentTank.pos.y;
    parentTank.ableToFire = true; //allow the tank that shot this missile to fire again
    isFired = false;
    normalAngle = 0;
    canBounce = true;
  }
  
  
  
  
  
  class Tank {
  PVector pos  = new PVector(0.0, 0.0);

  float forwardSpeed = .5;
  float backwardSpeed = .5;

  float rotateSpeed = .025;
  float angle;

  int health = 100;
  boolean ableToFire = true;
  Bullet bullet = new Bullet();

  int hue; //not related to the tank color...
  int number;
  boolean keys[] = {false, false, false, false, false, false}; // W A S D Q *or* I J K L O
  boolean controlScheme; //if true then player uses WASD if false then player uses IJKL

  Tank(int num) {
    number = num;
    if (num == 1) {
      controlScheme = true;
      pos.x = 200;
      pos.y = 200;
      hue = 0;
      angle = 0;
    } else if (num == 2) {
      controlScheme = false;
      pos.x = 800;
      pos.y = 200;
      hue = 155;
      angle = 3.14;
    }
  }

  void display() {
    translate(pos.x, pos.y);
    rotate(angle);

    if (controlScheme) { //display red tank for player 1 and blue for 2
      image(redTank, 0, 0);
    } else {
      image(blueTank, 0, 0);
    }

    rotate(-angle);
    translate(-1*pos.x, -1*pos.y); //reset the origin to the top left of the screen
  }

  void move() {
    if (keys[0]) { //WWWWW
      pos.x += 1/(forwardSpeed/cos(angle));
      pos.y += 1/(forwardSpeed/sin(angle));
    }
    if (keys[1]) { //AAAAA
      angle -= rotateSpeed;
    }
    if (keys[2]) { //SSSSS
      pos.x -= 1/(backwardSpeed/cos(angle));
      pos.y -= 1/(backwardSpeed/sin(angle));
    }
    if (keys[3]) { //DDDDD
      angle += rotateSpeed;
    }
    if (keys[4]) {
      if (ableToFire) {
        if (number == 1) {
          bullet.Launch(player1, angle, player2); //first parrameter is the parent tank second is the target
        } else if (number == 2) {
          bullet.Launch(player2, angle, player1); //first parrameter is the parent tank second is the target
        }
      }
    }
  } 

  void displayScore(int x, int y) { //x,y are the position of the displayted score, h is the color
    textSize(30);
    fill(hue, 255, 160, 255);
    text("Player " + number +": " + health, x, y);
  }

  void keyPressed() {
    if (controlScheme == true) {
      if (key == 'w') {
        keys[0] = true;
      }
      if (key == 'a') {
        keys[1] = true;
      }
      if (key == 's') {
        keys[2] = true;
      }
      if (key == 'd') {
        keys[3] = true;
      }
      if (key == 'q') {
        keys[4] = true;
      }
    } else if (controlScheme == false) {
      if (key == 'i') {
        keys[0] = true;
      }
      if (key == 'j') {
        keys[1] = true;
      }
      if (key == 'k') {
        keys[2] = true;
      }
      if (key == 'l') {
        keys[3] = true;
      }
      if (key == 'o') {
        keys[4] = true;
      }
    }
  }

  void keyReleased() {
    if (controlScheme == true) {
      if (key == 'w') {
        keys[0] = false;
      } 
      if (key == 'a') {
        keys[1] = false;
      }
      if (key == 's') {
        keys[2] = false;
      }
      if (key == 'd') {
        keys[3] = false;
      }
      if (key == 'q') {
        keys[4] = false;
      }
    } 
    if (controlScheme == false) {
      if (key == 'i') {
        keys[0] = false;
      } 
      if (key == 'j') {
        keys[1] = false;
      }
      if (key == 'k') {
        keys[2] = false;
      }
      if (key == 'l') {
        keys[3] = false;
      }
      if (key == 'o') {
        keys[4] = false;
      }
    }
  }
}







class Wall {
  PVector pos = new PVector(0.0, 0.0);
  int H;
  int W;

  Wall(int x, int y, int h) {
    pos.x = x;
    pos.y = y;
    H = h;
    W = 20;
  }

  void display() {
    noStroke();
    fill(25, 85, 255);
    rect(pos.x, pos.y, W, H);
  }
}



class PowerUp {
  PVector pos  = new PVector(0.0, 0.0);
  float r;
  float r2;

  float startTime;

  float h; //hue (color)
  float t = 255; //transparency

  PowerUp() {
    r = 10;
    r2 = 50; //ending circle radius
    h = 0;
    randomPosition(); // give the circle a random position
  }

  void display() { 
    update();
    noStroke();
    fill(h, 0, 255, 255);
    ellipse(pos.x, pos.y, 20, 20); //constant dot
    noFill();
    strokeWeight(4);
    stroke(h, 0, 255, t); 
    ellipse(pos.x, pos.y, r, r); //growing ring
  }

  void update() {
    r = lerp(r, r2, 0.04); // increase current raduis (r) to max radius (r2) by step 0.04
    t = (255*(1-(r/r2))); //decrease transparency (as a percentage of the radius)

    if (r >= r2*.95) {
      r = 0;
      t = 255;
    }
  }

  void collect(Tank T) {
    if ((dist(T.pos.x, T.pos.y, pos.x, pos.y) <= 30)&&(T.health < 100)){ //if the tank is close enough to the health and the health of the tank is less than max 100...
      T.health += 5;
      randomPosition();
    }
  }

  void randomPosition() {
    pos.x = random(r, width-r); //random width position
    pos.y = random(r, height-r); //random height position
  }
}

  void display() {
    noStroke();
    fill(0, 0, 0);
    translate(pos.x, pos.y);
    ellipse(0, 0, radius, radius);
    translate(-1*pos.x, -1*pos.y);
  }
}

    
  </script>
  <canvas id="mycanvas0"></canvas>
  
  


    
  <!*********************************************************************************>
  <br />
  <br />  
  <br />
  <!*********************************************************************************>
  

  
  
  <h1>My First sketch</h1>
  <script type="text/processing" data-processing-target="mycanvas1">
    
   void setup(){
  
   size(400,400);
   background(0, 0, 0);
   
   //dots(background) 
   for(int x = 1; x < 400; x++){  
     for(int y = 1; y < 400; y++){  
       if ((x % 10 == 0) && (y % 10 == 0)){
         stroke(random(255), random(255), random(255));
           point(x,y);
       }
     }
   }
   
   //coin shape
   stroke(0, 0, 0); //black
   fill(200, 200, 200); //light grey
   ellipseMode(CENTER);
   ellipse(200, 200, 360, 360);
   ellipse(200, 200, 345, 345);
   
   
   
   //dome
   ellipse(200, 160, 125, 100); 
   
   rectMode(CENTER);
   rect(200, 160, 175, 25);
   rect(200, 250, 300, 20);
   rect(200, 200, 275, 80);
   rect(200, 200, 250, 80);
   rect(200, 200, 200, 80);
   rect(200, 200, 100, 70);
   rect(200, 250, 125, 25);
   
   
   //stairs
   line(140, 257, 260, 257);
   line(150, 252, 250, 252);
   line(160, 247, 240, 247);
   line(170, 242, 230, 242);
   
   //angled roof
   triangle(150, 165, 200, 140, 250, 165);
   rect(200, 172, 100, 10); 
   
   //pillars (left to right, top rect to bottom)
   rectMode(CENTER);
   rect(160, 180, 15, 5);
   rect(160, 207, 7, 50);
   rect(160, 235, 15, 5); 
   
   rect(180, 180, 15, 5);
   rect(180, 207, 7, 50);
   rect(180, 235, 15, 5); 
   
   rect(220, 180, 15, 5);
   rect(220, 207, 7, 50);
   rect(220, 235, 15, 5); 
   
   rect(240, 180, 15, 5);
   rect(240, 207, 7, 50);
   rect(240, 235, 15, 5); 
   
   //door
   rect(200, 215, 20, 35);
   
   //windows (left to right)
   rectMode(CORNER);
   rect(83, 185, 10, 20);
   rect(120, 180, 15, 35);
   rect(265, 180, 15, 35);
   rect(308, 185, 10, 20);
   
   //text
   fill(50, 50, 50); //text color
   textSize(15);
   text("Five Cents", 165, 300); 
   textSize(25);
   text("United States of", 103, 330); 
   text("America", 155, 360); 
   textSize(20);
   text("E Pluribus Unum", 120, 80); 
}

void draw () { //helps get coordinates when drawing
  println (mouseX +"," + mouseY);
} 
    
  </script>
  <canvas id="mycanvas1"></canvas>
  
  
  
  
  

  <!*********************************************************************************>
  <br />
  <br />  
  <br />
  <!*********************************************************************************>
  
  
  
  
  
  
  
  <h1>My Fifth sketch</h1>
  <script type="text/processing" data-processing-target="mycanvas5">
    
    float posX = width/2;
float posY = height/2;
float speed = 3;
int roadWidth = 200;
color carColor;
int d;

void setup() {
  size(1200, 700);
  posX = width/2;
  posY = height/2;
  carColor = color(random(255), random(255), random(255));
  textSize(20);
  rectMode(CENTER);
  noStroke();
}

void draw() {

  background(#147900); //grass

  fill(#E0E0E0);
  rect(width/2, height/2, roadWidth+50, height+2);//gravel
  fill(#B9B9B9);
  rect(width/2, height/2, roadWidth, height+2);//pavement

  if (d>=height) {
    d = 0;
  }
  drawLines(d);
  d+=speed;


  if ((posX < width/2-roadWidth/2-25)||(posX > width/2+roadWidth/2+25)) { //if car goes off road, decrease speed
    if (frameCount % 10 == 0) {
      speed--;
    }
    if (speed <= 3) { //set minimum speed to 3
      speed = 3;
    }
  } else if (frameCount % 50 == 0) { // increase the speed every 50th frame
    speed++;
    if (speed >= 10) { //set speed cap at 10
      speed = 10;
    }
  }

  if (keyPressed == true) { //WASD car control
    switch(key) {
      case('w'):
      case('W'):
      posY -= speed;
      break;
      case('d'):
      case('D'):
      posX += speed*0.5; //right speed is half normal speed
      break;
      case('s'):
      case('S'):
      posY += speed;
      break;
      case('a'):
      case('A'):
      posX -= speed*0.5;//left speed is half normal speed
      break;
    }
  }
  drawCar(posX, posY); //draws Car on Screen

  fill(#FFFFFF);

  text("- Use the W A S D keys to move the car", 20, 30);
  text("- Click to change the color of the car", 20, 55);
  text("tip: Stay on the road to go faster", 20, 100);
  text("SPEED = "+speed, 1000, 30);
}

void drawCar(float x, float y) {
  stroke(#000000);

  fill(#292828);
  rect(x, y-25, 40, 5);//front Axle
  rect(x, y+25, 40, 5);//front Axle

  fill(#767676);//wheels
  rect(x-17, y-25, 10, 15, 4, 4, 4, 4);//FR
  rect(x+17, y-25, 10, 15, 4, 4, 4, 4);//FL
  rect(x-17, y+25, 10, 15, 4, 4, 4, 4);//RL
  rect(x+17, y+25, 10, 15, 4, 4, 4, 4);//RR

  fill(carColor);
  rect(x, y-5, 10, 75);//middle thin rectangle

  beginShape(); //front Fin
  vertex(x-10, y-45);
  vertex(x-18, y-35);
  vertex(x+18, y-35);
  vertex(x+10, y-45);
  endShape(CLOSE);

  triangle(x, y-25, x+15, y-10, x-15, y-10);//front triangle
  rect(x, y-5, 30, 10);//niddle rectangle
  triangle(x, y+30, x+15, y, x-15, y);//back triangle

  rect(x, y+35, 25, 7);//back fin

  beginShape();
  vertex(x, y+15);
  vertex(x-5, y);
  vertex(x-5, y-5);
  vertex(x+5, y-5);
  vertex(x+5, y);
  endShape(CLOSE);
}

void drawLines(int s) {
  stroke(#FFF300);

  for (int q = -1*height; q <= height; q+=100) {
    line(width/2, s+q, width/2, s+q+50);
  }
}

void mousePressed() {
  carColor = color(random(255), random(255), random(255)); //Changes color of car
}
    
  </script>
  <canvas id="mycanvas5"></canvas>
  
  
  

  <!*********************************************************************************>
  <br />
  <br />  
  <br />
  <!*********************************************************************************>
  

  
  
  
  
  <h1>My Sixth sketch</h1>
  <script type="text/processing" data-processing-target="mycanvas6">
    
   color currentColor;
color selectedColor;
color backgroundColor = color(0, 0, 0);
float r = random(0, TWO_PI); // ring rotation
float spiralOrientation = 0;
float triangleOrientation = 0;
boolean bool = false;


void setup() {
  size(800, 800);
  background(backgroundColor);
  noCursor();
  rectMode(CENTER);
  colorMode(HSB);
}


void draw() {
  background(backgroundColor);

  drawDots();
  drawGradientCircle();
  drawSpiral(spiralOrientation);
  drawSpinningCircles();
  drawCursor();
  drawCircleOfLines();
  drawTriangle(width/2, height/2, triangleOrientation);
  
  if(bool){
    filter(INVERT);
  }

  spiralOrientation = spiralOrientation - 0.1;
  triangleOrientation = triangleOrientation + 0.025;
}

void drawGradientCircle() {
  noFill();
  for (float t = 0.0; t <= TWO_PI; t = t + .15) {
    currentColor = color(255*(t/TWO_PI), 255, 255);
    stroke(currentColor);
    strokeWeight(20);
    point(width/2+200*cos(t), height/2+200*sin(t));
    stroke(0, 0, 255);
    strokeWeight(15);
    point(width/2+200*cos(t), height/2+200*sin(t));
  }
}

void drawSpinningCircles() {
  noFill();
  stroke(0, 0, 255);
  strokeWeight(2);
  ellipse(width/2, height/2, 450, 450);
  ellipse(width/2, height/2, 350, 350);

  strokeWeight(8);
  arc(width/2, height/2, 450, 450, triangleOrientation-PI/8+PI/3, triangleOrientation+PI/8+PI/3);
  arc(width/2, height/2, 350, 350, triangleOrientation-PI/16+PI/3, triangleOrientation+PI/16+PI/3);

  arc(width/2, height/2, 450, 450, triangleOrientation-PI/8+PI, triangleOrientation+PI/8+PI);
  arc(width/2, height/2, 350, 350, triangleOrientation-PI/16+PI, triangleOrientation+PI/16+PI);

  arc(width/2, height/2, 450, 450, triangleOrientation-PI/8-PI/3, triangleOrientation+PI/8-PI/3);
  arc(width/2, height/2, 350, 350, triangleOrientation-PI/16-PI/3, triangleOrientation+PI/16-PI/3);
}


void drawCursor() {
  noFill();
  int x = mouseX;
  int y = mouseY;

  stroke(0, 0, 255);
  strokeWeight(1);
  noFill();

  stroke(0, 0, 255);
  line(x+10, y, x-10, y); //crosshairs
  line(x, y-10, x, y+10);


  if (mousePressed) {
    rect(x, y, 35, 35); //rect
  } else {
    line(x-20, y-20, x-10, y-20); //corners only
    line(x+20, y-20, x+10, y-20);
    line(x-20, y+20, x-10, y+20);
    line(x+20, y+20, x+10, y+20);

    line(x-20, y-20, x-20, y-10);
    line(x+20, y-20, x+20, y-10);
    line(x-20, y+20, x-20, y+10);
    line(x+20, y+20, x+20, y+10);
  }

  //r = atan2((1.0*mouseY-height/2), (1.0*mouseX-width/2)); //angle from center based on mouse position
}

void drawSpiral(float a) {
  stroke(0, 0, 255);
  fill(0, 0, 255);
  strokeWeight(1);
  ellipse(width/2, height/2, 7, 7);
  for (float z = 0; z <= PI*18.5; z = z + 0.005) {
    point(width/2+3*z*cos(z+a), height/2+3*z*sin(z+a));
  }
}

void drawCircleOfLines() {
  for (float t = 0.0; t <= TWO_PI; t = t + .1) {
    strokeWeight(2);
    line (width/2+250*cos(t), height/2+250*sin(t), width/2+255*cos(t), height/2+255*sin(t));
  }
}

void drawDots() {
  strokeWeight(1);
  stroke(0, 0, 255);
  for (int q = 0; q <= 10; q++) {
    point(random(width), random(height));
  }
}

void drawTriangle(int x, int y, float b) {
  stroke(0, 0, 255);
  beginShape();
  for (float s = b; s <= b + TWO_PI; s = s + 2*PI/3) {
    vertex(x+250*cos(s), y+250*sin(s));
  }
  endShape(CLOSE);
}

void mousePressed(){
  bool =! bool;
}
   
  </script>
  <canvas id="mycanvas6"></canvas>
  
  

  
  
  <!*********************************************************************************>
  <br />
  <br />  
  <br />
   <!*********************************************************************************>

  
  
  
  
  
  
  <h1>My Seventh sketch</h1>
  <script type="text/processing" data-processing-target="mycanvas7">
    
   Food[] myFoods = new Food[10];
Food currentFood = new Food();

Person myPerson = new Person();
Timer myTimer = new Timer();

int numEaten = 0;

PImage burger;
PImage fork;
PImage background;

boolean paused = false;

void setup() {
  size(1000, 750);
  colorMode(RGB);
  imageMode(CORNERS);
  noSmooth();
  noCursor();

  textSize(50);
  fill(0, 255, 0);

  fork = loadImage("https://cloud.githubusercontent.com/assets/14878231/11727668/d5079db4-9f4a-11e5-8f66-f6bc45ab28c1.png");
  burger = loadImage("https://cloud.githubusercontent.com/assets/14878231/11727652/ba53b714-9f4a-11e5-9a56-c349c4a77154.png");
  background = loadImage("https://cloud.githubusercontent.com/assets/14878231/11727670/dbda4efc-9f4a-11e5-8e6c-29cb3ced8a10.gif");


  for (int i = 0; i < myFoods.length; i++) { //initialize array
    myFoods[i] = new Food();
  }

  myTimer.Begin();
}


void draw() {
  image(background, 0, 0, width, height); //background

  myPerson.move();
  myPerson.display();

  myTimer.display();


  for (int i = 0; i < myFoods.length; i++) { 
    currentFood = myFoods[i];

    currentFood.renderFood();
    currentFood.updateFoodPos();

    println("eaten " + numEaten + " out of " + myFoods.length);
  }

  if (numEaten >= myFoods.length) {
    println("game is over");
    myTimer.display();
  } else {
    myTimer.endTime = millis();
  }
}






class Timer {
  float startTime;
  float endTime;
  float time;

  Timer() {
  }

  void Begin() {
    startTime = millis();
  }


  void display() {
    text((endTime - startTime)/1000.0, 10, 50);
  }

  void resetTimer() {
    startTime = millis();
  }
}





class Person {
  int posX = width/2;
  int posY = height/2;

  int d = 100;
  int speed = 10;

  Person() {
  }

  void display() {
    image(fork, posX-130, posY-50, posX+30, posY+50);
  }

  void move() {
    posX = mouseX;
    posY = mouseY;

    if (posX >= width-d/2) {
      posX = width-d/2;
    }
    if (posX <= 0+d/2) {
      posX = 0+d/2;
      if (posY >= height-d/2) {
        posY = height-d/2;
      }
      if (posY <= 0+d/2) {
        posY = 0+d/2;
      }
    }
  }
}




class Food {
  float x;
  float y;
  float sx;
  float sy;
  float r = 50;
  boolean eaten = false;

  Food() {
    x = random(r, width-r);
    y = random(r, height-r);
    do {
      sx = round(random(-5, 5));
    } while (sx == 0); //select a random x speed until its not equal to zero
    do {
      sy = round(random(-5, 5));
    } while ((sy == 0)||(sy == sx));//select a random y speed until its not equal to zero AND the x speed
  }

  void renderFood() {
    if (eaten == false) {
      image(burger, x-50, y-50, x+50, y+50);
    }
  }

  void updateFoodPos() {
    x += sx;
    y += sy;

    if ((x <= 0+r)||(x >= width-r)) {
      sx *= -1;
    }
    if ((y <= 0+r)||(y >= height-r)) {
      sy *= -1;
    }
  }
}






void mousePressed() {
  if (mousePressed == true) {
    for (int i = 0; i < myFoods.length; i++) { 
      currentFood = myFoods[i];
      if (currentFood.eaten == false) {
        if (dist(currentFood.x, currentFood.y, myPerson.posX, myPerson.posY) <= 50) {
          currentFood.eaten = true;
          numEaten++;
        }
      }
    }
  }
}

void keyPressed() {
  if (key == 'r') {
    resetGame();
  }
  if (key == ' ') {
    paused =! paused;
    if (paused) {
      noLoop();
    } else {
      loop();
    }
  }
}

void resetGame() {
  for (int i = 0; i < myFoods.length; i++) { 
    currentFood = myFoods[i];
    currentFood.eaten = false;
  }
  numEaten = 0;
  myTimer.startTime = millis();
  myTimer.endTime = 0;
}
   
  </script>
  <canvas id="mycanvas7"></canvas>
  

  
  <!*********************************************************************************>
  <br />
  <br />  
  <br />
  <!*********************************************************************************>

  
  
  
   <!--
  
  
  <h1>My Eigth sketch</h1>
  <script type="text/processing" data-processing-target="mycanvas8">
    
   int squareSize = 20; //number of tiles
int numFoods = 10;

boolean gameOver = false;

Timer myTimer;

int[] gridX = new int[width/squareSize];
int[] gridY = new int[height/squareSize];

Food[] food = new Food[numFoods];

Snake player1 = new Snake();

void setup() {
  size(1005, 750);
  rectMode(CENTER);
  textAlign(CENTER, CENTER);
  imageMode(CORNERS);
  colorMode(HSB);

  myTimer = new Timer();
  myTimer.Start();

  for (int n = 0; n < food.length; n++) {
    food[n] = new Food();
  }
}

void draw() {
  if (frameCount%6 == 0) {
    background(0, 0, 0);
    drawGrid();
    player1.render();
    player1.updatePos();
    for (int n = 0; n < food.length; n++) {
      food[n].render();
    }
    myTimer.getPassedTime();
    println(myTimer.passedTime);
  }
}

void drawGrid() {
  fill(0, 0, 255, 100);
  stroke(0, 0, 255, 50);
  for (int x = squareSize; x <= width-squareSize; x+=squareSize) {
    for (int y = squareSize; y <= height-squareSize; y+=squareSize) {
      rect(x, y, squareSize-1, squareSize-1);
    }
  }
}

void gameOver() {
  gameOver = true;
  myTimer.End();
  myTimer.getPassedTime();

  filter(INVERT);

  fill(0, 0, 255);
  println("GAME OVER");
  textSize(100);
  text("GAME OVER", width/2, height/2-75);
  textSize(50);
  text("Snake Length = " + player1.snakeLength, width/2, height/2+30);
  textSize(40);
  text("Game Time - " + myTimer.passedTime + " seconds", width/2, height/2+80);
  textSize(25);
  text("Click to restart", width/2, height/2+115);
  noLoop();
}

void mousePressed() {
  if (gameOver) {
    loop();
    player1.reset();
    myTimer.Start();
    gameOver = false;
  }
}






class Food {
  PImage img;

  int posX;
  int posY;

  float t = 100; //transparency

  Food() {
    img = loadImage("food.png");

    posX = round(random(1, width/squareSize))*squareSize;
    posY = round(random(1, height/squareSize))*squareSize;
  }

  void render() {
    image(img, posX-squareSize/2, posY-squareSize/2, posX+squareSize/2, posY+squareSize/2);
    //fill(h, 255, 255, t);
    //ellipse(posX, posY, squareSize-2, squareSize-2);
  }

  void reset() {
    posX = round(random(1, width/squareSize))*squareSize;
    posY = round(random(1, height/squareSize))*squareSize;
  }
}





class Snake {
  int maxLength = 350;
  int initialLength = 6;

  int[] Xpositions = new int[maxLength];
  int[] Ypositions = new int[maxLength];

  int posX; // of the head of the snake
  int posY; // ''

  int snakeLength;

  int direction; // 1 = right, 2 = up, 3 = left, 4 = down 

  float h; // hue (color) of the snake

  Snake() {
    h = round(random(255));
    snakeLength = initialLength;
    posX = round(random(10, width/squareSize))*squareSize;
    posY = round(random(10, height/squareSize))*squareSize;
    direction = int(random(1, 4));
  }

  void updatePos() {
    if (keyPressed) { //get the direction based on key pressed
      switch(key) {
      case 'w':
        direction = 2; 
        break;
      case 'a':
        direction = 3;
        break;
      case 's':
        direction = 4;
        break;
      case 'd':
        direction = 1; 
        break;
      }
    }
    switch(direction) { //move the snake based on current direction ov movement
    case 1:
      posX += squareSize; 
      break;
    case 2:
      posY -= squareSize; 
      break;
    case 3:
      posX -= squareSize; 
      break;
    case 4:
      posY += squareSize; 
      break;
    }

    for (int i = snakeLength; i > 0; i = i - 1) { 
      Xpositions[i] = Xpositions[i-1]; //shif x positions in array to the right
      Ypositions[i] = Ypositions[i-1]; //shif Y positions in array to the right
      if ((posX == Xpositions[i])&&(posY == Ypositions[i])) { //if the position of the head == any of the positions of the other body parts...
        gameOver();
      }
    }

    Xpositions[0] = posX; //set the first value of the x positions array to the current xposition
    Ypositions[0] = posY; //set the first value of the y positions array to the current y position


    if ((posX > width-squareSize)||(posX < squareSize)) { //if the head of the snake goes off the left or right side...
      gameOver();
    }
    if ((posY > height-squareSize)||(posY < squareSize)) { //if the head of the snake goes off the top or bottom of the screen...
      gameOver();
    }

    for (int n = 0; n < food.length; n++) { //cycle through food positions
      if ((food[n].posX == posX) && (food[n].posY == posY)) { //if the head position is equal to any of the food positons...
        snakeLength += 3;//add 3 to the length when you eat a food
        food[n].reset(); //move the fruit to a new place
      }
    }

    //println(direction + " " + posX + "," + posY); //direction and position of the head
  }

  void render() {
    for (int i = 0; i < snakeLength; i++) { //draw the last #(snakeLenght) positions of the head
      h = 225*(i*1.0/snakeLength); //rainbow snake
      fill(int(h), 255, 255);
      rect(Xpositions[i], Ypositions[i], squareSize-3, squareSize-3);//draw the body part
    }
  }

  void reset() {
    for (int i = 0; i < maxLength; i++) { //reset snake body parts positions to 0 (x and y)
      Xpositions[i] = 0;
      Ypositions[i] = 0;
    }

    snakeLength = initialLength;

    posX = 10*squareSize; //reset the x position of the head to a random position on the board
    posY = 10*squareSize; //reset the y position of the head to a random position on the board
    Xpositions[0] = posX;
    Ypositions[0] = posY;

    direction = int(random(1, 4)); //set the direction randomly (see direction variable declaration above for explanation)...

    h = round(random(255)); //set the solor of the snake to a random color
  }
}








class Timer{
  float startTime;  // When Timer started
  float endTime; //When the timer is stopped
  float passedTime;
  
  // The constructor, set how long the Timer last with integer value
  Timer(){
    
  }
  
  // Start the Timer
  void Start() {
    startTime = millis();
  }
  void End(){
    endTime = millis();
  }
  void getPassedTime(){
    passedTime = (endTime - startTime)/1000;
  }
}
   
  </script>
  <canvas id="mycanvas8"></canvas>
  
  
  
  
  <!*********************************************************************************>
  <br />
  <br />  
  <br />
   <!*********************************************************************************>
  
  
    
 
  -->
  
  </body>
</html> 

